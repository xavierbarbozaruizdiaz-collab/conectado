/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user profiles and uses public read with owner-only writes for products and banners.
 * Affiliate data and affiliate events are also protected with owner-only access. Platform settings and subscription tiers are read-only for all users. Orders are accessible by the user who placed the order.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information.
 * - /products/{productId}: Stores product information.
 * - /orders/{orderId}: Stores order information.
 * - /affiliates/{affiliateId}: Stores affiliate user data.
 * - /banners/{bannerId}: Stores banner information.
 * - /config/platform: Stores platform settings.
 * - /affiliateEvents/{eventId}: Stores affiliate event data.
 * - /subscriptionTiers/{tierId}: Stores subscription tier information.
 *
 * Key Security Decisions:
 * - User profiles are owner-only (users can only read/write their own profile data).
 * - Products and banners are publicly readable, but only the owner can create, update, or delete them.
 * - Affiliate data and affiliate events are owner-only.
 * - Platform settings and subscription tiers are globally readable but not writable by clients.
 * - Orders are accessible only by the user who placed the order.
 * - Listing of users, affiliates, and affiliate events is disallowed.
 *
 * Denormalization for Authorization:
 * - Products have a `sellerId` field to determine ownership.
 * - Orders have a `userId` field to determine ownership.
 *
 * Structural Segregation:
 * - No explicit structural segregation is used.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile document with matching UID.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their own profile.
     * @deny (create) User 'user456' attempts to create a profile document for 'user123'.
     * @deny (get, update, delete) User 'user456' attempts to read/update/delete the profile of 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to product documents. Products are publicly readable, but only the seller can modify them.
     * @path /products/{productId}
     * @allow (get, list) Any user can read or list products.
     * @allow (create) User with ID 'user123' creates a product with `sellerId: 'user123'`.
     * @allow (update, delete) User with ID 'user123' updates/deletes a product where `resource.data.sellerId == 'user123'`.
     * @deny (create) User with ID 'user456' creates a product with `sellerId: 'user123'`.
     * @deny (update, delete) User with ID 'user456' attempts to update/delete a product where `resource.data.sellerId == 'user123'`.
     * @principle Allows public read access but enforces document ownership for writes.
     */
    match /products/{productId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(sellerId) {
        return request.auth.uid == sellerId;
      }

      function isExistingOwner(sellerId) {
        return isSignedIn() && isOwner(sellerId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.sellerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.sellerId == request.auth.uid;
    }

    /**
     * @description Controls access to order documents. Only the user who placed the order can read it, and no one can list all orders.
     * @path /orders/{orderId}
     * @allow (get) User with ID 'user123' reads their order with `userId: 'user123'`.
     * @deny (get) User with ID 'user456' attempts to read order where `userId: 'user123'`.
     * @deny (list) Any user attempts to list all orders.
     * @allow (create) Any signed-in user can create an order.
     * @deny (update, delete) No one is allowed to update or delete an order after creation.
     * @principle Restricts order access to the owning user and prevents listing.
     */
    match /orders/{orderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to affiliate documents.
     * @path /affiliates/{affiliateId}
     * @allow (create) User with ID 'user123' creates their affiliate document with matching UID.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their own affiliate data.
     * @deny (create) User 'user456' attempts to create an affiliate document for 'user123'.
     * @deny (get, update, delete) User 'user456' attempts to read/update/delete the affiliate data of 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /affiliates/{affiliateId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(affiliateId) {
        return request.auth.uid == affiliateId;
      }

       function isExistingOwner(affiliateId) {
        return isSignedIn() && isOwner(affiliateId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(affiliateId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(affiliateId);
      allow update: if isSignedIn() && isOwner(affiliateId);
      allow delete: if isSignedIn() && isOwner(affiliateId);
    }

    /**
     * @description Controls access to banner documents. Banners are publicly readable, but only an admin can modify them.
     * @path /banners/{bannerId}
     * @allow (get, list) Any user can read or list banners.
     * @allow (create) User with ID 'user123' creates a banner.
     * @allow (update, delete) User with ID 'user123' updates/deletes a banner.
     * @deny (create) User with ID 'user456' creates a banner.
     * @deny (update, delete) User with ID 'user456' attempts to update/delete a banner.
     * @principle Allows public read access but enforces document ownership for writes.
     */
    match /banners/{bannerId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to the platform configuration. The configuration is globally readable, but not writable via the client.
     * @path /config/platform
     * @allow (get, list) Any user can read the platform configuration.
     * @deny (create, update, delete) No user can create, update, or delete the platform configuration via the client.
     * @principle Provides global read access but restricts write access.
     */
    match /config/platform {
      allow get: if true;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

   /**
     * @description Controls access to affiliate event documents.
     * @path /affiliateEvents/{eventId}
     * @allow (create) User with ID 'user123' creates their affiliate event document with matching UID.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their own affiliate event data.
     * @deny (create) User 'user456' attempts to create an affiliate event document for 'user123'.
     * @deny (get, update, delete) User 'user456' attempts to read/update/delete the affiliate event data of 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /affiliateEvents/{eventId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(affiliateId) {
        return request.auth.uid == affiliateId;
      }

      allow get: if isSignedIn() && resource.data.affiliateId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.affiliateId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.affiliateId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.affiliateId == request.auth.uid;
    }

    /**
     * @description Controls access to subscription tier documents. The subscription tiers are globally readable, but not writable via the client.
     * @path /subscriptionTiers/{tierId}
     * @allow (get, list) Any user can read the subscription tiers.
     * @deny (create, update, delete) No user can create, update, or delete the subscription tiers via the client.
     * @principle Provides global read access but restricts write access.
     */
    match /subscriptionTiers/{tierId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}